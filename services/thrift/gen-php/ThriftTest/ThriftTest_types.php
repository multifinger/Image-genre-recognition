<?php
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
include_once $GLOBALS['THRIFT_ROOT'].'/Thrift.php';


$GLOBALS['thrift.test_E_Numberz'] = array(
  'ONE' => 1,
  'TWO' => 2,
  'THREE' => 3,
  'FIVE' => 5,
  'SIX' => 6,
  'EIGHT' => 8,
);

final class thrift.test_Numberz {
  const ONE = 1;
  const TWO = 2;
  const THREE = 3;
  const FIVE = 5;
  const SIX = 6;
  const EIGHT = 8;
  static public $__names = array(
    1 => 'ONE',
    2 => 'TWO',
    3 => 'THREE',
    5 => 'FIVE',
    6 => 'SIX',
    8 => 'EIGHT',
  );
}

class thrift.test_Bonk {
  static $_TSPEC;

  public $message = null;
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'Bonk';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bonk');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Bools {
  static $_TSPEC;

  public $im_true = null;
  public $im_false = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'im_true',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'im_false',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['im_true'])) {
        $this->im_true = $vals['im_true'];
      }
      if (isset($vals['im_false'])) {
        $this->im_false = $vals['im_false'];
      }
    }
  }

  public function getName() {
    return 'Bools';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_true);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_false);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bools');
    if ($this->im_true !== null) {
      $xfer += $output->writeFieldBegin('im_true', TType::BOOL, 1);
      $xfer += $output->writeBool($this->im_true);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->im_false !== null) {
      $xfer += $output->writeFieldBegin('im_false', TType::BOOL, 2);
      $xfer += $output->writeBool($this->im_false);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Xtruct {
  static $_TSPEC;

  public $string_thing = null;
  public $byte_thing = null;
  public $i32_thing = null;
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 4);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Xtruct2 {
  static $_TSPEC;

  public $byte_thing = null;
  public $struct_thing = null;
  public $i32_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => 'thrift.test_Xtruct',
          ),
        3 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new thrift.test_Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct2');
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 1);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 3);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Xtruct3 {
  static $_TSPEC;

  public $string_thing = null;
  public $changed = null;
  public $i32_thing = null;
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'changed',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['changed'])) {
        $this->changed = $vals['changed'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct3';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->changed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct3');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->changed !== null) {
      $xfer += $output->writeFieldBegin('changed', TType::I32, 4);
      $xfer += $output->writeI32($this->changed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Insanity {
  static $_TSPEC;

  public $userMap = null;
  public $xtructs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userMap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'xtructs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'thrift.test_Xtruct',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userMap'])) {
        $this->userMap = $vals['userMap'];
      }
      if (isset($vals['xtructs'])) {
        $this->xtructs = $vals['xtructs'];
      }
    }
  }

  public function getName() {
    return 'Insanity';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->userMap = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = 0;
              $val6 = 0;
              $xfer += $input->readI32($key5);
              $xfer += $input->readI64($val6);
              $this->userMap[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->xtructs = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $elem12 = new thrift.test_Xtruct();
              $xfer += $elem12->read($input);
              $this->xtructs []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Insanity');
    if ($this->userMap !== null) {
      if (!is_array($this->userMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userMap', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I32, TType::I64, count($this->userMap));
        {
          foreach ($this->userMap as $kiter13 => $viter14)
          {
            $xfer += $output->writeI32($kiter13);
            $xfer += $output->writeI64($viter14);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->xtructs !== null) {
      if (!is_array($this->xtructs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('xtructs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->xtructs));
        {
          foreach ($this->xtructs as $iter15)
          {
            $xfer += $iter15->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_CrazyNesting {
  static $_TSPEC;

  public $string_field = null;
  public $set_field = null;
  public $list_field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_field',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'set_field',
          'type' => TType::SET,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => 'thrift.test_Insanity',
            ),
          ),
        3 => array(
          'var' => 'list_field',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::SET,
            'vtype' => TType::MAP,
            'key' => array(
              'type' => TType::SET,
              'etype' => TType::I32,
              'elem' => array(
                'type' => TType::I32,
                ),
            ),
            'val' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::SET,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::SET,
                'etype' => TType::LST,
                'elem' => array(
                  'type' => TType::LST,
                  'etype' => TType::MAP,
                  'elem' => array(
                    'type' => TType::MAP,
                    'ktype' => TType::STRUCT,
                    'vtype' => TType::STRING,
                    'key' => array(
                      'type' => TType::STRUCT,
                      'class' => 'thrift.test_Insanity',
                    ),
                    'val' => array(
                      'type' => TType::STRING,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_field'])) {
        $this->string_field = $vals['string_field'];
      }
      if (isset($vals['set_field'])) {
        $this->set_field = $vals['set_field'];
      }
      if (isset($vals['list_field'])) {
        $this->list_field = $vals['list_field'];
      }
    }
  }

  public function getName() {
    return 'CrazyNesting';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::SET) {
            $this->set_field = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readSetBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $elem21 = new thrift.test_Insanity();
              $xfer += $elem21->read($input);
              $this->set_field[$elem21] = true;
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->list_field = array();
            $_size22 = 0;
            $_etype25 = 0;
            $xfer += $input->readListBegin($_etype25, $_size22);
            for ($_i26 = 0; $_i26 < $_size22; ++$_i26)
            {
              $elem27 = null;
              $elem27 = array();
              $_size28 = 0;
              $_ktype29 = 0;
              $_vtype30 = 0;
              $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
              for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                $key33 = array();
                $val34 = array();
                $key33 = array();
                $_size35 = 0;
                $_etype38 = 0;
                $xfer += $input->readSetBegin($_etype38, $_size35);
                for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
                {
                  $elem40 = null;
                  $xfer += $input->readI32($elem40);
                  $key33[$elem40] = true;
                }
                $xfer += $input->readSetEnd();
                $val34 = array();
                $_size41 = 0;
                $_ktype42 = 0;
                $_vtype43 = 0;
                $xfer += $input->readMapBegin($_ktype42, $_vtype43, $_size41);
                for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
                {
                  $key46 = 0;
                  $val47 = array();
                  $xfer += $input->readI32($key46);
                  $val47 = array();
                  $_size48 = 0;
                  $_etype51 = 0;
                  $xfer += $input->readSetBegin($_etype51, $_size48);
                  for ($_i52 = 0; $_i52 < $_size48; ++$_i52)
                  {
                    $elem53 = null;
                    $elem53 = array();
                    $_size54 = 0;
                    $_etype57 = 0;
                    $xfer += $input->readListBegin($_etype57, $_size54);
                    for ($_i58 = 0; $_i58 < $_size54; ++$_i58)
                    {
                      $elem59 = null;
                      $elem59 = array();
                      $_size60 = 0;
                      $_ktype61 = 0;
                      $_vtype62 = 0;
                      $xfer += $input->readMapBegin($_ktype61, $_vtype62, $_size60);
                      for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
                      {
                        $key65 = new thrift.test_Insanity();
                        $val66 = '';
                        $key65 = new thrift.test_Insanity();
                        $xfer += $key65->read($input);
                        $xfer += $input->readString($val66);
                        $elem59[$key65] = $val66;
                      }
                      $xfer += $input->readMapEnd();
                      $elem53 []= $elem59;
                    }
                    $xfer += $input->readListEnd();
                    $val47[$elem53] = true;
                  }
                  $xfer += $input->readSetEnd();
                  $val34[$key46] = $val47;
                }
                $xfer += $input->readMapEnd();
                $elem27[$key33] = $val34;
              }
              $xfer += $input->readMapEnd();
              $this->list_field []= $elem27;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CrazyNesting');
    if ($this->string_field !== null) {
      $xfer += $output->writeFieldBegin('string_field', TType::STRING, 1);
      $xfer += $output->writeString($this->string_field);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_field !== null) {
      if (!is_array($this->set_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_field', TType::SET, 2);
      {
        $output->writeSetBegin(TType::STRUCT, count($this->set_field));
        {
          foreach ($this->set_field as $iter67 => $true)
          {
            $xfer += $iter67->write($output);
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_field !== null) {
      if (!is_array($this->list_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_field', TType::LST, 3);
      {
        $output->writeListBegin(TType::MAP, count($this->list_field));
        {
          foreach ($this->list_field as $iter68)
          {
            {
              $output->writeMapBegin(TType::SET, TType::MAP, count($iter68));
              {
                foreach ($iter68 as $kiter69 => $viter70)
                {
                  {
                    $output->writeSetBegin(TType::I32, count($kiter69));
                    {
                      foreach ($kiter69 as $iter71 => $true)
                      {
                        $xfer += $output->writeI32($iter71);
                      }
                    }
                    $output->writeSetEnd();
                  }
                  {
                    $output->writeMapBegin(TType::I32, TType::SET, count($viter70));
                    {
                      foreach ($viter70 as $kiter72 => $viter73)
                      {
                        $xfer += $output->writeI32($kiter72);
                        {
                          $output->writeSetBegin(TType::LST, count($viter73));
                          {
                            foreach ($viter73 as $iter74 => $true)
                            {
                              {
                                $output->writeListBegin(TType::MAP, count($iter74));
                                {
                                  foreach ($iter74 as $iter75)
                                  {
                                    {
                                      $output->writeMapBegin(TType::STRUCT, TType::STRING, count($iter75));
                                      {
                                        foreach ($iter75 as $kiter76 => $viter77)
                                        {
                                          $xfer += $kiter76->write($output);
                                          $xfer += $output->writeString($viter77);
                                        }
                                      }
                                      $output->writeMapEnd();
                                    }
                                  }
                                }
                                $output->writeListEnd();
                              }
                            }
                          }
                          $output->writeSetEnd();
                        }
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Xception extends TException {
  static $_TSPEC;

  public $errorCode = null;
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'Xception';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_Xception2 extends TException {
  static $_TSPEC;

  public $errorCode = null;
  public $struct_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => 'thrift.test_Xtruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
    }
  }

  public function getName() {
    return 'Xception2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new thrift.test_Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception2');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_EmptyStruct {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'EmptyStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmptyStruct');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_OneField {
  static $_TSPEC;

  public $field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'field',
          'type' => TType::STRUCT,
          'class' => 'thrift.test_EmptyStruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['field'])) {
        $this->field = $vals['field'];
      }
    }
  }

  public function getName() {
    return 'OneField';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->field = new thrift.test_EmptyStruct();
            $xfer += $this->field->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OneField');
    if ($this->field !== null) {
      if (!is_object($this->field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('field', TType::STRUCT, 1);
      $xfer += $this->field->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_VersioningTestV1 {
  static $_TSPEC;

  public $begin_in_both = null;
  public $old_string = null;
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'old_string',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['old_string'])) {
        $this->old_string = $vals['old_string'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->old_string);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV1');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->old_string !== null) {
      $xfer += $output->writeFieldBegin('old_string', TType::STRING, 3);
      $xfer += $output->writeString($this->old_string);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_VersioningTestV2 {
  static $_TSPEC;

  public $begin_in_both = null;
  public $newint = null;
  public $newbyte = null;
  public $newshort = null;
  public $newlong = null;
  public $newdouble = null;
  public $newstruct = null;
  public $newlist = null;
  public $newset = null;
  public $newmap = null;
  public $newstring = null;
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'newint',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'newbyte',
          'type' => TType::BYTE,
          ),
        4 => array(
          'var' => 'newshort',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'newlong',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'newdouble',
          'type' => TType::DOUBLE,
          ),
        7 => array(
          'var' => 'newstruct',
          'type' => TType::STRUCT,
          'class' => 'thrift.test_Bonk',
          ),
        8 => array(
          'var' => 'newlist',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        9 => array(
          'var' => 'newset',
          'type' => TType::SET,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        10 => array(
          'var' => 'newmap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        11 => array(
          'var' => 'newstring',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['newint'])) {
        $this->newint = $vals['newint'];
      }
      if (isset($vals['newbyte'])) {
        $this->newbyte = $vals['newbyte'];
      }
      if (isset($vals['newshort'])) {
        $this->newshort = $vals['newshort'];
      }
      if (isset($vals['newlong'])) {
        $this->newlong = $vals['newlong'];
      }
      if (isset($vals['newdouble'])) {
        $this->newdouble = $vals['newdouble'];
      }
      if (isset($vals['newstruct'])) {
        $this->newstruct = $vals['newstruct'];
      }
      if (isset($vals['newlist'])) {
        $this->newlist = $vals['newlist'];
      }
      if (isset($vals['newset'])) {
        $this->newset = $vals['newset'];
      }
      if (isset($vals['newmap'])) {
        $this->newmap = $vals['newmap'];
      }
      if (isset($vals['newstring'])) {
        $this->newstring = $vals['newstring'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->newint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->newbyte);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->newshort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->newlong);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->newdouble);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->newstruct = new thrift.test_Bonk();
            $xfer += $this->newstruct->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->newlist = array();
            $_size78 = 0;
            $_etype81 = 0;
            $xfer += $input->readListBegin($_etype81, $_size78);
            for ($_i82 = 0; $_i82 < $_size78; ++$_i82)
            {
              $elem83 = null;
              $xfer += $input->readI32($elem83);
              $this->newlist []= $elem83;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::SET) {
            $this->newset = array();
            $_size84 = 0;
            $_etype87 = 0;
            $xfer += $input->readSetBegin($_etype87, $_size84);
            for ($_i88 = 0; $_i88 < $_size84; ++$_i88)
            {
              $elem89 = null;
              $xfer += $input->readI32($elem89);
              $this->newset[$elem89] = true;
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->newmap = array();
            $_size90 = 0;
            $_ktype91 = 0;
            $_vtype92 = 0;
            $xfer += $input->readMapBegin($_ktype91, $_vtype92, $_size90);
            for ($_i94 = 0; $_i94 < $_size90; ++$_i94)
            {
              $key95 = 0;
              $val96 = 0;
              $xfer += $input->readI32($key95);
              $xfer += $input->readI32($val96);
              $this->newmap[$key95] = $val96;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newstring);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV2');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newint !== null) {
      $xfer += $output->writeFieldBegin('newint', TType::I32, 2);
      $xfer += $output->writeI32($this->newint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newbyte !== null) {
      $xfer += $output->writeFieldBegin('newbyte', TType::BYTE, 3);
      $xfer += $output->writeByte($this->newbyte);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newshort !== null) {
      $xfer += $output->writeFieldBegin('newshort', TType::I16, 4);
      $xfer += $output->writeI16($this->newshort);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlong !== null) {
      $xfer += $output->writeFieldBegin('newlong', TType::I64, 5);
      $xfer += $output->writeI64($this->newlong);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newdouble !== null) {
      $xfer += $output->writeFieldBegin('newdouble', TType::DOUBLE, 6);
      $xfer += $output->writeDouble($this->newdouble);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstruct !== null) {
      if (!is_object($this->newstruct)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newstruct', TType::STRUCT, 7);
      $xfer += $this->newstruct->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlist !== null) {
      if (!is_array($this->newlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newlist', TType::LST, 8);
      {
        $output->writeListBegin(TType::I32, count($this->newlist));
        {
          foreach ($this->newlist as $iter97)
          {
            $xfer += $output->writeI32($iter97);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newset !== null) {
      if (!is_array($this->newset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newset', TType::SET, 9);
      {
        $output->writeSetBegin(TType::I32, count($this->newset));
        {
          foreach ($this->newset as $iter98 => $true)
          {
            $xfer += $output->writeI32($iter98);
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newmap !== null) {
      if (!is_array($this->newmap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newmap', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::I32, TType::I32, count($this->newmap));
        {
          foreach ($this->newmap as $kiter99 => $viter100)
          {
            $xfer += $output->writeI32($kiter99);
            $xfer += $output->writeI32($viter100);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstring !== null) {
      $xfer += $output->writeFieldBegin('newstring', TType::STRING, 11);
      $xfer += $output->writeString($this->newstring);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_ListTypeVersioningV1 {
  static $_TSPEC;

  public $myints = null;
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'myints',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['myints'])) {
        $this->myints = $vals['myints'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->myints = array();
            $_size101 = 0;
            $_etype104 = 0;
            $xfer += $input->readListBegin($_etype104, $_size101);
            for ($_i105 = 0; $_i105 < $_size101; ++$_i105)
            {
              $elem106 = null;
              $xfer += $input->readI32($elem106);
              $this->myints []= $elem106;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV1');
    if ($this->myints !== null) {
      if (!is_array($this->myints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('myints', TType::LST, 1);
      {
        $output->writeListBegin(TType::I32, count($this->myints));
        {
          foreach ($this->myints as $iter107)
          {
            $xfer += $output->writeI32($iter107);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class thrift.test_ListTypeVersioningV2 {
  static $_TSPEC;

  public $strings = null;
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'strings',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['strings'])) {
        $this->strings = $vals['strings'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->strings = array();
            $_size108 = 0;
            $_etype111 = 0;
            $xfer += $input->readListBegin($_etype111, $_size108);
            for ($_i112 = 0; $_i112 < $_size108; ++$_i112)
            {
              $elem113 = null;
              $xfer += $input->readString($elem113);
              $this->strings []= $elem113;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV2');
    if ($this->strings !== null) {
      if (!is_array($this->strings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('strings', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->strings));
        {
          foreach ($this->strings as $iter114)
          {
            $xfer += $output->writeString($iter114);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

?>
